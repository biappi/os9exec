**	@(#)cstart.a	2.1.8	2/23/89******************************** cstart.a - C program startup routine* use .../defs/oskdefs.dTyp equ 1Edit equ 7Stk equ 2048+1024 some default stack sizeCerror equ 257 arbitrary C error psect cstart_a,(Prgrm<<8)!Objct,(ReEnt<<8)!1,Edit,Stk,_cstart,trapinitcr equ $0dspace equ $20comma equ $2cdquote equ $22squote equ $27*   variable declarations vsect_sttop ds.l 1 stack top (also robs address zero) ends** the following are globally known* vsect_mtop: ds.l 1 current non-stack memory top_stbot: ds.l 1 current stack bottom limiterrno: ds.l 1 global error holder_totmem: ds.l 1 total data memory used_sbsize: ds.l 1 top of process memory (sbrk)_fcbs: dc.l _iob file control block ptr (for cio)environ: dc.l EVNULL environment pointer (for getenv)_pathcnt: ds.w 1 number of path open on process creation_sysglob: ds.l 1 ptr to system globals (if system-state process) ends** C Program entry point*_cstart: move.l d6,_totmem(a6) save initial data size move.l d6,_sbsize(a6) save for sbrk, too move.w d3,_pathcnt(a6) save number of paths open btst.b #SupStBit,M$Attr(a3) system-state module? beq.s _cs10 nope, forget it move.l a4,_sysglob(a6) save system global ptr bne.s _cs10 kernel gave sysglob ptr move.l 0.l,_sysglob(a6) old method assumes sysglob @ 0_cs10**   process the params* tst.l d5 parameter length zero? beq.s oldarg.a yes, must be from os9fork() or chain() btst #0,d5 odd argument length? bne.s oldarg yes, new os9forks are nicer... lea (a5,d5.l),a0 point to the end of the args tst.w -2(a0) new-style argv? bne.s oldarg no, use the old-style argument procedure subq.l #4,a0 skip the envp terminator lea -4(a0),a4 ptr to last envp (or argv) moveq #1,d0 trip counter bra.s newarg.b oldarg clr.b -1(a5,d5.l) clear final param byte (which is a $0d [shell])oldarg.a move.l a5,a0 copy parameters ptr adda.l M$Name(a3),a3 make module name the first parameter clr.l -(sp) a null ptr for argv termination move.l a3,-(sp) save it (argv[0]) moveq.l #1,d2 at least one arg (argc=d2.l)* bsr _initarg to be replaced by 32-bit flavored call... move.l #_initarg-*-8,d0 _initarg trashes d0, so why can't we? jsr (pcr,d0.l) bra.s iobinitnewarg.a lea 4(a0),a1 move.l a1,environ(a6) save the environ ptr moveq #0,d2 argc countnewarg.b move.l -(a0),a1 get the offset move.l a1,d7 zero? beq.s newarg.c end of list adda.l a5,a1 change offset to pointer clr.b -1(a1) terminate previous string with null move.l a1,(a0) restore pointer addq.l #1,d2 bump argc count bra.s newarg.bnewarg.c subq.l #1,d0 do argv pointers now? beq.s newarg.a yes, one more time  tst.l d2 first argument really there? bne.s newarg.e no, don't mess with it tst.w -2(a0) arguments given? (see os9exec) beq.s newarg.e yes, one was... clr.b -1(a0) zap the <cr> env terminator movea.l a0,a2 save for argv[0] check addq.l #4,a0 adjust arg pointer bra.s newarg.fnewarg.e move.l a5,(a0) fix argv[1] movea.l a0,a2 save for argv[0] check addq.l #1,d2 started one arg too lownewarg.f addq.l #1,d2 always one argument: argv[0] tst.l (a4) argv[n] or envp[n] exist? beq.s newarg.i bra if not move.l (a4),a4 get last arg ptrnewarg.g tst.b (a4)+ find the null byte bne.s newarg.g loop if not null cmpa.l a4,a2 gap exist? bls.s newarg.s nope, not argv[0] method cmpi.b #0xfc,(a4)+ sync code here? bne.s newarg.s forget it, not argv[0] method addq.l #1,a4 skip version byte move.l (a4),a3 get argv[0] offset adda.l a5,a3 convert to ptr bra.s newarg.tnewarg.i cmpi.b #0xfc,2(a5) argv[0] method? bne.s newarg.s bra if not move.l 4(a5),a3 get argv[0] offset adda.l a5,a3 convert to ptr bra.s newarg.tnewarg.s adda.l M$Name(a3),a3 get name pointernewarg.t move.l a3,-(a0) fix argv[0] move.l a0,-(sp) save argv for later clr.b -1(a0) zap the <cr> env terminator move.l d2,-(sp) save argc for later * bra.s iobinit <<<fall thru to>>> ** Go process the arguments from command line* Some programs, like the shell, want to have* their own argument parser.** The arg init function should place the argument pointer* list on the stack; the top two entries being argv and argc.* The _initarg function will have to snitch it's return address* from the stack, place the inorder arg pointer there, and jump* back to the calling address.  It is OK that the stack is effectively* fouled up after this, but no harm is done since cstart never returns* to a caller (it just calls F$Exit to die).** The stack frame returned by _initarg should look like:**   ------------*   |   argn   |*   ------------*   | argn - 1 |*   ------------*   | argn - 2 |*   ------------*   | argn - n |*   ------------*   |   argv   |*   ------------*   |   argc   |    <-- Top of Stack on return*   ------------**initarg bsr _initarg** Initialize C I/O.* This call sets up the C I/O facility.  The function _iobinit sets up* everything required to do I/O.  It is possible that the I/O could be* done "inline" or through an "I/O trap handler".  Each case requires* a different setup.  The _iobinit the linker sees first will determine* which method of I/O will be used.*iobinit* bsr _iobinit to be replaced with a 32-bit call... move.l #_iobinit-*-8,a0 C stuff doesn't send things through a0, so we use it jsr (pcr,a0.l) bcs die branch if error** Setup environment and call the main() function* bsr.s _fixtop set various variables movem.l (sp)+,d0-d1 retrieve argc & argv suba.l a5,a5 clear future link register move.l environ(a6),-(sp) environment ptr* bsr main call the program (to be replaced by 32-bit call...) move.l #main-*-8,a0 C stuff doesn't send things through a0, so we use it jsr (pcr,a0.l) moveq #0,d0 exit status zero* bsr exit and exit...(turned into 32-bit call...) move.l #exit-*-8,a0 jsr (pcr,a0.l)* no return here** Stack-check related functions*_fixtop move.l #end,a0 adda.l a6,a0 get initial memory allocation* lea end(a6),a0 get initial memory end addr move.l a0,_mtop(a6) it's the current memory top move.l a7,_sttop(a6) (really 4-bytes short) move.l a7,_stbot(a6) move.l #-252,d0 make some breathing room* on entry here, d0 holds the negative of a stack reservation request_stkchec:_stkcheck: add.l a7,d0 cmp.l _stbot(a6),d0 lower than already reserved? blo.s stk10 yes, keep checking rts no, get out faststk10 cmp.l _mtop(a6),d0 lower than possible? blo.s fsterr yes, can't cope move.l d0,_stbot(a6) no, reserve it rts and return*fsterr lea fixserr(pc),a0 bsr.s PrtMsg move.l #Cerror,-(a7)* bsr _exit and out (turn into 32-bit call...) move.l #_exit-*-8,a0 jsr (pcr,a0.l)* no return here** Print message*PrtMsg move.w d1,-(sp) save old error code moveq #100,d1 bytes to write moveq #2,d0 std output os9 I$WritLn write it move.w (sp)+,d1 rts ** stacksize()* returns the extent of stack requested* can be used by programmer for guidance* in sizing memory at compile time*stacksiz: move.l _sttop(a6),d0 top of stack on entry sub.l _stbot(a6),d0 less current reserved limit rts** freemem()* returns the current size of the free memory area*freemem: move.l _stbot(a6),d0 sub.l _mtop(a6),d0 rts**   Uninitialized Trap Handler**   stack:  (a7) = caller's a6*          4(a7) = trap code*          6(a7) = trap vector*          8(a7) = trap return addresstrapinit: movem.l d0-d1/a0-a3,-(a7) save registersstacked set 6*4 move.w 6+stacked(a7),d0 get trap vector subi.w #$80,d0 convert to trap number asr.w #2,d0 cmpi.w #T$Math,d0 Math package 1? bne.s tryuser lea m1nam(pc),a0trap.x moveq #0,d1 clear additional memory os9 F$TLink install trap module bcc.s trap.ytryuser* bsr _utinit let user try it (turned into 32-bit call...)* NOTE: we are using a1 for the 32-bit call, since it appears that* _utinit had better conform to the interface that F$TLink assumes.* This may come as a surprise to those who try to write _utinit in C. move.l #_utinit-*-8,a1 jsr (pcr,a1.l) bcs.s die branch if errortrap.y movem.l (a7)+,d0-d1/a0-a3 retrieve registers addq.l #8,a7 fix stack subq.l #4,(a7) rts dc.w 0x4afb for debugger dc.w StrEnd-*-2 for debuggerfixserr dc.b "**** Stack Overflow ****" dc.b $0d,0TrapErr dc.b "**** Can't install trap handler ****" dc.b $0d,0TrapEr1 dc.b " **** " dc.b 0m1nam dc.b "math",0 alignEVNULL dc.l 0 (A Null environ list)StrEndbadtrap move.l #E$IllFnc,d1die move.l a0,-(sp) save traphandler name lea TrapErr(pc),a0 bsr PrtMsg* once this said "lea _iob(a6),a1"... movea.l #_iob,a1 adda.l a6,a1 lea TrapEr1(pc),a0 bsr.s mover move.l (sp)+,a0 get name subq.l #1,a1 bsr.s mover lea TrapEr1(pc),a0 subq.l #1,a1 bsr.s mover move.b #$0d,-1(a1) the return* ...and this once said "lea _iob(a6),a0", but now, in case there's* LOTS of data, we say... movea.l #_iob,a0 adda.l a6,a0 bsr PrtMsg os9 F$Exit die with error os9 F$Exit the debugger shows this on exitmover move.b (a0)+,(a1)+ bne.s mover copy string rts ends