 nam Example User trap handler use <oskdefs.d>type equ (TrapLib<<8)+Objctrevs equ (SupStat<<8)+(ReEnt<<8)edit equ 7	cstart verifies edition numberstack equ 4*512+100 psect CTTrap_a,type,revs,edit,stack,CTTrap dc.l initial dc.l terminat_sysedit: equ edit edition number of module vsecterrnoptr: ds.l 1 ptr to caller's "errno"freturn: ds.l 1 function return addressfstorage: ds.l 1 function storage address_caller: ds.l 1 calling module addresserrno: ds.l 1 error numberenviron: ds.l 1 environement pointer ends*   Trap Initialization**   input:   (a7) = caller's a6*           4(a7) = 0*           6(a7) = trap vector*           8(a7) = return address of trap**	The following is passed in registers by the*	"cstart" routine:**		(d3) = Pointer to caller's environ variable*		(a3) = Pointer to caller's errno variable*		(a4) = Pointer to caller's program module** Any of the registers not actually changed by the F$TLink system* call can be used to pass arguments to the trap handler.  Since the* linkage to the trap handler and the calling program are resolved at* execution time, the only way to pass data back and forth is via* pointers.  This example handles errno, environ and a pointer to the* calling module.*initial: movem.l d0/a0,-(a7) save registersstacked set 2*4 move.l a3,errnoptr(a6) save caller's "errno" ptr move.l d3,environ(a6) save caller's "environ" ptr move.l a4,_caller(a6) save addr of calling module movem.l (a7)+,d0/a0/a6-a7 retrieve registers & scratch rts** Nothing really to do here.  The kernel will clean up after* the process (memory, paths, etc.)*terminat: rts*   Trap Entry**   input:   (a7) = caller's a6*           4(a7) = trap code*           6(a7) = trap vector*           8(a7) = return address of trap*          12(a7) = return address of function callCTTrap: movem.l d0/a0,-(a7) save registersstacked set 2*4 move.w 4+stacked(a7),d0 get function code cmpi.w #maxtrap,d0 in range? bhs.s badtrap branch if not move.l 0+stacked(a7),fstorage(a6) ; save function storage lea DispTab(pc),a0 get dispatch table ptr asl.w #1,d0 shift for two-byte entries move.w (a0,d0.w),d0 get routine offset lea (a0,d0.w),a0 get address move.l a0,0+stacked(a7) replace trap code/vector move.l 10+stacked(a7),freturn(a6) save function return lea CTRet(pc),a0 return here move.l a0,4+stacked(a7) replace function return movem.l (a7)+,d0/a0 restore registers clr.l errno(a6) clear error code rts dispatch to routineCTRet: tst.l errno(a6) any error code? beq.s CIORet.a branch if not move.l a0,-(a7) save register move.l errnoptr(a6),a0 get caller's "errno" ptr move.l errno(a6),(a0) return error number move.l (a7)+,a0 retrieve registerCIORet.a move.l fstorage(a6),a6 retrieve storage ptr rts returnbadtrap: movem.l (a7)+,d0/a0 retrieve registers move.l (a7)+,a6 retrieve storage ptr move.l 4(a7),(a7) copy trap return address move.l #E$IllFnc,4(a7) return error number rts** This table corresponds to the "trapdefs.a" offset* table.  Each entry in the following table has* a matching entry in the offset table.  When a program* is linked against the cttrap.l library, the offset directs this trap* handler to the appropriate entry in the dispatch table.* Severe havoc will result if a mismatch occurs.**   Dispatch Table*DispTab: dc.w ct_get-DispTab dc.w ct_set-DispTab dc.w ct_clear-DispTabmaxtrap equ (*-DispTab)/2 ends