/******************************************************************* *                                                                 * *       Dieses Programm ist urheberrechtlich geschuetzt!!!        * *                                                                 * *  Copyrights (c) 1987 by recc-O-ware, Wolfgang Ocker, Puchheim   * *                                                                 * ******************************************************************* ******************************************************************* * Editon History  screen.c * *  #    Date      Comments                                      By * -- --------- ------------------------------------------------ --- * 00  11/05/88 Fixed for release.                               weo * 01  11/15/88 'l' and '-nl' didn't work (wrong parameter *              in _ss_screen() call.) Corrected.                weo * 02  02/21/89 screen saver time computation incorrect. Corr.   weo * 03  04/02/89 To uninstall a keydef module, we must supply *              _ss_screen with a NULL pointer                   weo * 04  10/23/89 To uninstall a font module, we must supply *              _ss_screen with a NULL pointer                   weo * */#include <stdio.h>#include <modes.h>#include <ctype.h>#include <screen.h>#define TRUE  1#define FALSE 0extern int errno;/* * m a i n */  main(argc, argv)  int  argc;  char *argv[];{  int    i, j, negated;  int    saver, blinkrate, mode, kbrate, kbdelay, keydef, smooth, click;  int    mouse, res, foregr, backgr, freq, datasz, small, font;  int    tmp;  int    path;  SCREEN screen;  saver = blinkrate = mode = kbrate = kbdelay = keydef = smooth = click = FALSE;  mouse = res = foregr = backgr = freq = datasz = small = font = FALSE;  /*   * Get screen status   */  if (_gs_screen(1, &screen) < 0)    exit(_errmsg(errno, "Can't get screen status\n"));  /*   * When no arguments are given, display status   */  if (argc == 1) {    puts("screen settings:");    printf("  resolution:         %s\n",           screen.res == 0 ? "high" : (screen.res == 1 ? "mid" : "low"));    if (screen.saver)      printf("  screen saver (ca.): %d min\n", (int) screen.saver/(60*30));    else      puts("  screen saver:       off");    printf("  key repeat:         %d, delay:   %d\n",           screen.kbrate, screen.kbdelay);    if (screen.blinkrate)      printf("  cursor blinking:    %d\n", screen.blinkrate);    else      puts("  cursor blinking:   off");    printf("  smooth scroll:      %s\n", screen.smooth ? "on" : "off");    printf("  data mode:          %s\n", screen.datasz ? "8 Bit" : "7 Bit");    printf("  click:              %s\n", screen.click ? "on" : "off");    printf("  mode:               %s\n", screen.mode ? "invers" : "normal");    printf("  lines:              %s\n", screen.small ? "50(48)" : "25(24)");    printf("  foreground:         %03x\n", screen.foregr);    printf("  background:         %03x\n", screen.backgr);    printf("  frequency:          %2d Hz\n", screen.freq == 0 ?           50 : (screen.freq == 1 ? 60 : 70));    printf("  mouse:              %s\n", screen.mouse ? "enabled" : "disabled");    printf("  key definition:     %s\n", screen.keydef[0] ?           screen.keydef : "none");    printf("  font module:        %s\n", screen.font[0] ? screen.font : "none");    printf("  video base:         %x\n", screen.vidbase);    printf("  pixels per line     %d\n", screen.xsize);    printf("  video lines         %d\n", screen.ysize);    printf("  number of planes    %d\n", screen.planes);    exit(0);  }  /*   * Parse options   */    for (i = 1; i < argc; i++)    if (argv[i][0] == '-') {      negated = FALSE;      for (j = 1; j < strlen(argv[i]); j++)        switch (tolower(argv[i][j])) {          case '?':            usage();            exit(1);                      case 'n':         /* negate next option */            if (negated) {              usage();              exit(_errmsg(1, "Double negation not allowed\n"));            }            negated = TRUE;            break;          case 'p':         /* screen saver */            saver = TRUE;            if (negated) {              negated = FALSE;              screen.saver = 0;            }            else {              j += argv[i][j+1] == '=' ? 2 : 1;              if (!isdigit(argv[i][j]))                exit(_errmsg(1, "argument missing for 'p'\n"));              screen.saver = atoi(argv[i]+j) * 30 * 60;              while (isdigit(argv[i][j+1]))                j++;            }            break;          case 'b':         /* blink rate */            blinkrate = TRUE;            if (negated) {              negated = FALSE;              screen.blinkrate = 0;            }            else {              j += argv[i][j+1] == '=' ? 2 : 1;              if (!isdigit(argv[i][j]))                exit(_errmsg(1, "argument missing for 'b'\n"));              screen.blinkrate = atoi(argv[i]+j);              while (isdigit(argv[i][j+1]))                j++;            }            break;                case 'i':         /* inverse screen */            mode = TRUE;            if (negated) {              screen.mode = 1;              negated = FALSE;            }            else              screen.mode = 0;            break;          case 'r':         /* keyboard repeat rate */            kbrate = TRUE;            if (negated) {              negated = FALSE;              screen.kbrate = 0;            }            else {              j += argv[i][j+1] == '=' ? 2 : 1;              if (!isdigit(argv[i][j]))                exit(_errmsg(1, "argument missing for 'r'\n"));              screen.kbrate = atoi(argv[i]+j);              while (isdigit(argv[i][j+1]))                j++;            }            break;          case 'd':         /* keyboard repeat delay */            kbdelay = TRUE;            if (negated)              exit(_errmsg(1, "can't be negated: 'd'\n"));            else {              j += argv[i][j+1] == '=' ? 2 : 1;              if (!isdigit(argv[i][j]))                exit(_errmsg(1, "argument missing for 'r'\n"));              screen.kbdelay = atoi(argv[i]+j);              while (isdigit(argv[i][j+1]))                j++;            }            break;          case 'k':         /* keyboard definition file */            keydef = TRUE;            if (negated) {              negated = FALSE;              screen.keydef[0] = '\0';            }            else {              j += argv[i][j+1] == '=' ? 2 : 1;              strcpy(screen.keydef, argv[i] + j);              if ((path = open(screen.keydef, S_IREAD)) < 0)                exit(_errmsg(errno, "can't open keydef file\n"));              close(path);              j = strlen(argv[i]);            }            break;          case 's':         /* smooth scroll (not VTD) */            smooth = TRUE;            screen.smooth = !negated;            negated = FALSE;            break;          case 'c':         /* key click */            click = TRUE;            screen.click = !negated;            negated = FALSE;            break;          case 'f':         /* video refresh frequency */            freq = TRUE;            if (negated)              exit(_errmsg(1, "can't be negated: 'f'\n"));            else {              j += argv[i][j+1] == '=' ? 2 : 1;              if (!isdigit(argv[i][j]))                exit(_errmsg(1, "argument missing for 'f'\n"));              tmp = atoi(argv[i]+j);              switch (tmp) {                case 50:                  screen.freq = 0;                  break;                case 60:                  screen.freq = 1;                  break;                case 70:                  screen.freq = 2;                  break;                default:                  exit(_errmsg("unknown frequency '%s'\n", argv[i]+j));              }              while (isdigit(argv[i][j+1]))                j++;            }            break;                    case '0':         /* foreground color */            foregr = TRUE;            if (negated)              exit(_errmsg(1, "can't be negated: '0'\n"));            else {              j += argv[i][j+1] == '=' ? 2 : 1;              if (!isxdigit(argv[i][j]))                exit(_errmsg(1, "argument missing for 'r'\n"));              sscanf(argv[i]+j, "%x", &tmp);              if (tmp & 0xFFFFF888)                exit(_errmsg(1, "invalid color '%s'\n", argv[i]+j));              screen.foregr = tmp;              while (isxdigit(argv[i][j+1]))                j++;            }            break;          case '1':         /* background color */            backgr = TRUE;            if (negated)              exit(_errmsg(1, "can't be negated: '1'\n"));            else {              j += argv[i][j+1] == '=' ? 2 : 1;              if (!isxdigit(argv[i][j]))                exit(_errmsg(1, "argument missing for 'r'\n"));              sscanf(argv[i]+j, "%x", &tmp);              if (tmp & 0xFFFFF888)                exit(_errmsg(1, "invalid color '%s'\n", argv[i]+j));              screen.backgr = tmp;              while (isxdigit(argv[i][j+1]))                j++;            }            break;          case '7':         /* 7 bit data from keyboard */            datasz = TRUE;            if (negated)              exit(_errmsg(1, "can't be negated: '7'\n"));            else              screen.datasz = 1;            break;          case '8':         /* 8 bit data from keyboard */            datasz = TRUE;            if (negated)              exit(_errmsg(1, "can't be negated: '8'\n"));            else              screen.datasz = 0;            break;          case 'm':         /* mouse */            mouse = TRUE;            screen.mouse = !negated;            negated = FALSE;            break;          case 'l':         /* resolution (low/mid) */            res = TRUE;            screen.res = negated ? 1 : 2;            negated = FALSE;            break;                    case 'a':         /* 48/50 lines */            small = TRUE;            screen.small = !negated;            negated = FALSE;            break;                      case 'o':         /* font */            font = TRUE;            if (negated) {              negated = FALSE;              screen.font[0] = '\0';            }            else {              j += argv[i][j+1] == '=' ? 2 : 1;              strcpy(screen.font, argv[i] + j);              j = strlen(argv[i]);              if ((path = open(screen.font, S_IREAD)) < 0)                exit(_errmsg(errno, "can't open font file\n"));              else                close(path);            }            break;          default:            exit(_errmsg(1, "unknown option '%c'\n", argv[i][j]));        }    }    else {      usage();      exit(_errmsg(1, "unrecognized parameter '%s'\n", argv[i]));    }  /*   * and now ... do it!   */  if (small)      _ss_screen(1, SCR_SMALL, screen.small);  if (res)    _ss_screen(1, SCR_RES, screen.res);  if (saver)    _ss_screen(1, SCR_SAVE, screen.saver);  if (blinkrate)    _ss_screen(1, SCR_BLINK, screen.blinkrate);  if (mode)    _ss_screen(1, SCR_MODE, screen.mode);          if (kbrate)    _ss_screen(1, SCR_RATE, screen.kbrate);  if (kbdelay)    _ss_screen(1, SCR_DELAY, screen.kbdelay);  if (keydef)    _ss_screen(1, SCR_KEYDEF, screen.keydef[0] == '\0' ? NULL : screen.keydef);  if (smooth)    _ss_screen(1, SCR_SMOOTH, screen.smooth);  if (click)    _ss_screen(1, SCR_CLICK, screen.click);  if (foregr)    _ss_screen(1, SCR_FORE, screen.foregr);  if (backgr)    _ss_screen(1, SCR_BACK, screen.backgr);  if (freq)    _ss_screen(1, SCR_FREQ, screen.freq);  if (datasz)    _ss_screen(1, SCR_DATASZ, screen.datasz);  if (mouse)    _ss_screen(1, SCR_MOUSE, screen.mouse);  if (font)    _ss_screen(1, SCR_FONT, screen.font[0] == '\0' ? NULL : screen.font);}/* * u s a g e */usage(){  fputs("Syntax: screen {<opts>}\n", stderr);  fputs("Function: set screen attributes\n", stderr);  fputs("Options:\n", stderr);  fputs("     -p=<saver time>   time in minutes for screen saver\n", stderr);  fputs("     -np               turn screen saver of\n", stderr);  fputs("     -b=<blink rate>   cursor blink rate\n", stderr);  fputs("     -nb               steady cursor\n", stderr);  fputs("     -i                invers mode\n", stderr);  fputs("     -ni               normal mode\n", stderr);  fputs("     -7                7 bit data\n", stderr);  fputs("     -8                8 bit data\n", stderr);  fputs("     -r=<repeat rate>  keyboard repeat rate\n", stderr);  fputs("     -nr               no keyboard repeat\n", stderr);  fputs("     -d=<delay>        keyboard repeat delay\n", stderr);  fputs("     -k=<path>         keyboard definition file\n", stderr);  fputs("     -nk               no keyboard definition\n", stderr);  fputs("     -o=<path>         font file\n", stderr);  fputs("     -no               no special font\n", stderr);  fputs("     -[n]s             smooth scroll off/on\n", stderr);  fputs("     -[n]c             key click off/on\n", stderr);  fputs("     -[n]m             mouse disable/enable\n", stderr);  fputs("     -[n]a             25/50 lines on screen\n", stderr);  fputs("     -[n]l             low/mid monitor resolution\n", stderr);  fputs("     -f=[50|60]        CRT frequency 50/60hz\n", stderr);  fputs("     -0=<rgb>          foreground color (rgb)\n", stderr);  fputs("     -1=<rgb>          background color (rgb)\n", stderr);}