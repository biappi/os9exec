/* * Display contents of a MSDOS file *  * Emmet P. Gray			US Army, HQ III Corps & Fort Hood * ...!ihnp4!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV Directorate of * Engineering & Housing Environmental Management Office Fort Hood, TX * 76544-5057 ported to OS-9 by Michael Bähr */#include <stdio.h>#include <types.h>#include "msdos.h"int           fd;				  /* the file descriptor for						   * the floppy */int           dir_start;			  /* starting sector for						   * directory */int           dir_len;				  /* length of directory (in						   * sectors) */int           dir_entries;			  /* number of directory						   * entries */int           dir_chain[25];			  /* chain of sectors in						   * directory */int           clus_size;			  /* cluster size (in						   * sectors) */int           fat_len;				  /* length of FAT table (in						   * sectors) */int           num_clus;				  /* number of available						   * clusters */unsigned char *fatbuf;				  /* the File Allocation						   * Table */char          *mcwd;				  /* the Current Working						   * Directory */long          size;long          current;stripmode = 0;textmode  = 0;main(argc, argv)  int  argc;  char *argv[];{  int              fat, i, j, ismatch, entry, subdir(), c, oops;  char             *filename, *newfile, text[4], tname[9], *getname(), *unixname();  char             *strncpy(), *pathname, *getpath();  void             exit();  struct directory *dir, *search();  textmode = 1;					  /* default */  /* get command line options */  for (i = 1; i < argc; i++)    if (argv[i][0] == '-')      for (j = 1; j < strlen(argv[i]); j++)	switch (argv[i][j]) {	  case '?':	    usage();	    exit(1);	  case 't':	    textmode = 0;	    break;	  case 's':	    stripmode = 1;	    break;	  default:	    usage();	    exit(_errmsg(1, "unknown option '%c'\n", argv[i][j]));	}  if (init(_READ)) {    fprintf(stderr, "tostype: Cannot initialize diskette\n");    exit(1);  }  for (i = 1; i < argc; i++) {    if (argv[i][0] == '-')			  /* skip options */      continue;    filename = getname(argv[i]);    pathname = getpath(argv[i]);    if (subdir(pathname))      continue;    ismatch = 0;    for (entry = 0; entry < dir_entries; entry++) {      dir = search(entry);      /* if empty */      if (dir->name[0] == NULL)	break;      /* if erased */      if (dir->name[0] == 0xe5)	continue;      /* if dir or volume lable */      if ((dir->attr & 0x10) || (dir->attr & 0x08))	continue;      strncpy(tname, dir->name, 8);      strncpy(text, dir->ext, 3);      newfile = unixname(tname, text);      /* see it if matches the pattern */      if (match(newfile, filename)) {	fat  = dir->start[1] * 0x100 + dir->start[0];	size = dir->size[2] * 0x10000 + dir->size[1] * 0x100 + dir->size[0];	readit(fat);	ismatch = 1;      }    }        if (!ismatch) {      fprintf(stderr, "tostype: File '%s' not found\n", filename);      continue;    }  }    close(fd);  exit(0);}readit(fat)  int fat;{  current = 0L;  while (1) {    getcluster(fat);    /* get next cluster number */    fat = getfat(fat);    if (fat == -1) {      fprintf(stderr, "tostype: FAT problem\n");      exit(1);    }    /* end of cluster chain */    if (fat >= 0xff8)      break;  }  return(0);}getcluster(num)					  /* read a cluster */  int num;{  int  i, buflen, start;  void exit(), perror();  char buf[1024];  start = (num - 2) * clus_size + dir_start + dir_len;  move(start);  buflen = clus_size * MSECSIZ;  if (read(fd, buf, buflen) != buflen) {    perror("getcluster: read");    exit(1);  }    /* stop at size not EOF marker */  for (i = 0; i < buflen; i++) {    current++;    if (current > size)      break;    if (textmode && buf[i] == '\l')      continue;    if (textmode && buf[i] == '\x1a') {		  /* EOF */      current = size;      break;    }    if (stripmode)      putchar(buf[i] & 0x7f);    else      putchar(buf[i]);  }  return(0);}usage(){  fprintf(stderr, "Syntax: tostype [<opts>] {<tosfile>}\n");  fprintf(stderr, "Function: list TOS files to standard output\n");  fprintf(stderr, "Options:\n");  fprintf(stderr, "     -t        no text mode (no cr/lf -> cr mapping)\n");  fprintf(stderr, "     -s        strip high bit\n");  fprintf(stderr, "Environment:\n");  fprintf(stderr, "     TCWD      current TOS subdirectory\n");  fprintf(stderr, "     TDRV      drive number (0 or 1)\n");}