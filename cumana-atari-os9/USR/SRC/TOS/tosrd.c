/* * Delete a MSDOS sub directory *  * Emmet P. Gray			US Army, HQ III Corps & Fort Hood * ...!ihnp4!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV Directorate of * Engineering & Housing Environmental Management Office Fort Hood, TX * 76544-5057 ported to OS-9 by Michael Bähr */#include <stdio.h>#include <types.h>#include "msdos.h"int           fd;				  /* the file descriptor for						   * the floppy */int           dir_start;			  /* starting sector for						   * directory */int           dir_len;				  /* length of directory (in						   * sectors) */int           dir_entries;			  /* number of directory						   * entries */int           dir_chain[25];			  /* chain of sectors in						   * directory */int           clus_size;			  /* cluster size (in						   * sectors) */int           fat_len;				  /* length of FAT table (in						   * sectors) */int           num_clus;				  /* number of available						   * clusters */unsigned char *fatbuf;				  /* the File Allocation						   * Table */char          *mcwd;				  /* the Current Working						   * Directory */main(argc, argv)  int  argc;  char *argv[];{  int              i, j, ismatch, entry, start, isempty();  char             *dirname, *filename, *newfile, text[4], tname[9], *getname();  char             *strncpy(), *pathname, *getpath(), *unixname();  void             exit();  struct directory *dir, *search();  dirname = NULL;  for (i = 1; i < argc; i++)    if (argv[i][0] == '-')      for (j = 1; j < strlen(argv[i]); j++)	switch (tolower(argv[i][j])) {	  case '?':	    usage();	    exit(1);	  default:	    usage();	    exit(_errmsg(1, "unknown option '%c'\n",			 argv[i][j]));	}    else if (dirname) {      usage();      exit(_errmsg(1, "only one directory name allowed\n"));    }    else      dirname = argv[i];  /* only 1 directory ! */  if (init(_READ | _WRITE)) {    fprintf(stderr, "tosrd: Cannot initialize diskette\n");    exit(1);  }  filename = getname(dirname);  pathname = getpath(dirname);  if (subdir(pathname))    exit(1);  ismatch = 0;  for (entry = 0; entry < dir_entries; entry++) {    dir = search(entry);    /* if empty */    if (dir->name[0] == NULL)      break;    /* if erased */    if (dir->name[0] == 0xe5)      continue;    /* if not dir */    if (!(dir->attr & 0x10))      continue;    strncpy(tname, dir->name, 8);    strncpy(text, dir->ext, 3);    newfile = unixname(tname, text);    if (!strcmp(newfile, filename)) {      start = dir->start[1] * 0x100 + dir->start[0];      if (!isempty(start)) {	fprintf(stderr, "tosrd: Directory '%s' is not empty\n", filename);	exit(1);      }      if (!start) {	fprintf(stderr, "tosrd: Can't remove root directory\n");	exit(1);      }      zapit(start);      dir->name[0] = 0xe5;      writedir(entry, dir);      ismatch = 1;    }  }  if (!ismatch) {    fprintf(stderr, "tosrd: Directory '%s' not found\n", filename);    exit(1);  }  /* update the FAT sectors */  writefat();  close(fd);  exit(0);}/* * See if directory is empty.  Returns 1 if empty, 0 if not.  Can't use * subdir() and search() as it would clobber the globals. */int isempty(fat)  int fat;{  int           i, next, buflen, sector, getfat();  unsigned char tbuf[1024];  void          perror(), exit();  while (1) {    sector = (fat - 2) * clus_size + dir_start + dir_len;    move(sector);    buflen = clus_size * MSECSIZ;    if (read(fd, tbuf, buflen) != buflen) {      perror("isempty: read");      exit(1);    }    /* check first character of name */    for (i = 0; i < MSECSIZ; i += MDIRSIZ) {      if (tbuf[i] == '.')	continue;      if (tbuf[i] != NULL && tbuf[i] != 0xe5)	return(0);    }    /* get next cluster number */    next = getfat(fat);    if (next == -1) {      fprintf(stderr, "isempty: FAT problem\n");      exit(1);    }    /* end of cluster chain */    if (next >= 0xff8)      break;    fat = next;  }  return(1);}usage(){  fprintf(stderr, "Syntax: tosrd <tosdirectory>\n");  fprintf(stderr, "Function: delete TOS subdirectory\n");  fprintf(stderr, "Environment:\n");  fprintf(stderr, "     TCWD      current TOS subdirectory\n");  fprintf(stderr, "     TDRV      drive number (0 or 1)\n");}