/* * Initialize a MSDOS diskette.  Get the media signature (1st FAT entry) and * switch to the proper floppy disk device to match the format of the disk. * Sets a bunch of global variables.  Returns 0 on success, or 1 on failure. */#include <stdio.h>#include <types.h>#include <ctype.h>#include <sgstat.h>#include "msdos.h"extern int      errno;extern int      fd, dir_len, dir_start, clus_size, fat_len, num_clus;extern unsigned char *fatbuf;extern char     *mcwd;static unsigned char BootBuf[MSECSIZ];int init(mode)  int mode;{  int           code = 0, buflen;  struct sgbuf  rbfstat;  unsigned char read_fat(), fat;  char          *desc_name, *drive_no;  char          DiskBuffer[512];  char          *getenv(), *fixmcwd(), *malloc(), version, get_dos_ver();  long          lseek();  void          perror(), exit();  drive_no = getenv("TDRV");  if ((drive_no == NULL) || (atoi(drive_no) == 0))    desc_name = FLOPPY_0;  else    desc_name = FLOPPY_1;  /* open the 'generic' floppy */  if ((fd = open(desc_name, mode)) < 0) {    perror("init: open");    exit(1);  }  if (read(fd, DiskBuffer, 512) != 512)		  /* to read Sec 0 */    exit(_errmsg(errno, "can't init disk\n"));  lseek(fd, 0, 0);				  /* back ... */  _gs_opt(fd, &rbfstat);			  /* get path descriptor						   * options */  /* read media signature (1st FAT) */  fat = read_fat();  switch (fat) {    case 0xfe:      dir_start = 3;      dir_len   = 4;      clus_size = 1;      fat_len   = 1;      num_clus  = 313;      rbfstat.sg_cyls  = 40;      rbfstat.sg_sides = 1;      rbfstat.sg_spt   = 8;      rbfstat.sg_spt0  = 8;      rbfstat.sg_dense = 1;      break;    case 0xff:      dir_start = 3;      dir_len   = 7;      clus_size = 2;      fat_len   = 1;      num_clus  = 315;      rbfstat.sg_cyls  = 40;      rbfstat.sg_sides = 2;      rbfstat.sg_spt   = 8;      rbfstat.sg_spt0  = 8;      rbfstat.sg_dense = 1;      break;    case 0xfc:      dir_start = 5;      dir_len   = 4;      clus_size = 1;      fat_len   = 2;      num_clus  = 351;      rbfstat.sg_cyls  = 40;      rbfstat.sg_sides = 1;      rbfstat.sg_spt   = 9;      rbfstat.sg_spt0  = 9;      rbfstat.sg_dense = 1;      break;    case 0xfd:      dir_start = 5;      dir_len   = 7;      clus_size = 2;      fat_len   = 2;      num_clus  = 354;      rbfstat.sg_cyls  = 40;      rbfstat.sg_sides = 2;      rbfstat.sg_spt   = 9;      rbfstat.sg_spt0  = 9;      rbfstat.sg_dense = 1;      break;    case 0xf9:					  /* all 80 track disks */      version = get_dos_ver(BootBuf);      switch (version) {	case '0':	case '1':	  dir_start = 15;	  dir_len   = 14;	  clus_size = 1;	  fat_len   = 7;	  num_clus  = 1193;	  rbfstat.sg_cyls  = 80;	  rbfstat.sg_sides = 2;	  rbfstat.sg_spt   = 15;	  rbfstat.sg_spt0  = 15;	  rbfstat.sg_dense = 3;	  	  break;	case '2':	  dir_start = 7;	  dir_len   = 7;	  clus_size = 2;	  fat_len   = 3;	  num_clus  = 713;	  rbfstat.sg_cyls  = 80;	  rbfstat.sg_sides = 2;	  rbfstat.sg_spt   = 9;	  rbfstat.sg_spt0  = 9;	  rbfstat.sg_dense = 3;	  break;	case '\xf7':          dir_start = 11;          dir_len   = 7;          clus_size = 2;          fat_len   = 5;          num_clus  = 713;          rbfstat.sg_cyls  = 80;          rbfstat.sg_sides = 2;          rbfstat.sg_spt   = 9;          rbfstat.sg_spt0  = 9;          rbfstat.sg_dense = 3;          break;		default:	  fprintf(stderr, "Unknown DOS version %d\n", version);	  break;      }      break;          case 0xf7:					  /* Atari TOS format */      version = get_dos_ver(BootBuf);      dir_start = 11;      dir_len   = 7;      clus_size = 2;      fat_len   = 5;      num_clus  = 713;      rbfstat.sg_cyls  = 80;      rbfstat.sg_sides = 2;      rbfstat.sg_spt   = 9;      rbfstat.sg_spt0  = 9;      rbfstat.sg_dense = 3;      break;    default:      fprintf(stderr, "Unknown format '%02x'\n", fat);      code = 1;      break;  }    if (code)    return(1);  _ss_opt(fd, &rbfstat);  buflen = fat_len * MSECSIZ;  fatbuf = (unsigned char *) malloc(buflen);  move(1);  /* read the FAT sectors */  if (read(fd, fatbuf, buflen) != buflen) {    perror("init: read");    exit(1);  }  /* set dir_chain to root directory */  reset_dir();  /* get Current Working Directory */  mcwd = fixmcwd(getenv("TCWD") ? getenv("TCWD") : "/");  /* test it out.. */  if (subdir("")) {    fprintf(stderr, "Environmental variable TCWD needs updating\n");    exit(1);  }  return(0);}/* * Move the read/write head to the next location.  Tries to optimize the * movement by moving relative to current location.  The argument is a * logical sector number.  All errors are fatal. */move(sector)  int sector;{  long cur_loc, next, lseek();  void exit(), perror();  /* get current location */  if ((cur_loc = lseek(fd, 0L, 1)) < 0) {    perror("move: lseek");    exit(1);  }    next = (long) (MSECSIZ * sector) - cur_loc;  /* we're already there */  if (next == 0L)    return(0);  /* move to next location */  if (lseek(fd, next, 1) < 0) {    perror("move: lseek");    exit(1);  }  return(0);}/* * Fix MCWD to be a proper directory name.  Always has a leading separator. * Never has a trailing separator (unless it is the path itself). */char *fixmcwd(dirname)  char *dirname;{  char        *s, *malloc(), *strcpy(), *strcat();  static char *ans;  ans = malloc(strlen(dirname) + 2);  /* add a leading separator */  if (*dirname != '/' && *dirname != '\\') {    strcpy(ans, "/");    strcat(ans, dirname);  }  else    strcpy(ans, dirname);  /* translate to upper case */  for (s = ans; *s; ++s) {    if (islower(*s))      *s = toupper(*s);  }  /* if separator alone */  if (strlen(ans) == 1)    return (ans);  /* zap the trailing separator */  s--;  if (*s == '/' || *s == '\\')    *s = NULL;  return(ans);}/* * Read the first byte of the FAT table.  This code serves as a media * signature for the diskette. */unsigned char read_fat(){  unsigned char   buf[MSECSIZ];  static unsigned char ans;  /* move to boot sector */  if (lseek(fd, (long) MSECSIZ, 0) < 0) {    perror("init: lseek");    exit(1);  }    /* read the first FAT sector */  if (read(fd, buf, MSECSIZ) != MSECSIZ) {    perror("init: read");    exit(1);  }    ans = *buf;  return(ans);}/* * Read the Boot Sector to figure out the DOS version. */char get_dos_ver(bootbuf)  char *bootbuf;{  unsigned char bootbuf[MSECSIZ];  static char   ans;  /* move to boot sector */  if (lseek(fd, 0L, 0) < 0) {    perror("init: lseek");    exit(1);  }    /* read the boot sector */  if (read(fd, bootbuf, MSECSIZ) != MSECSIZ) {    perror("init: read");    exit(1);  }  ans = *(bootbuf + 10);  return(ans);}