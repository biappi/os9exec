 opt -l* the old "MPU020" conditional has now been replaced by "MPU020.030" ifdef MPU020MPU020.030 set 1 define the combined set if 68020 else ifdef MPU030MPU020.030 set 1 define the combined set if 68030 endc MPU030 endc MPU020********************************* OS9svc macro *   Direct call to OS9 service routine.* one argument: system call code, (a6)=system global ptrOS9svc macro ifne \#-1  must have exactly one argument   fail wrong number of arguments to OS9svc macro endc move.l a3,-(a7) save reg movea.l D_SysDis(a6),a3 get system dispatch tbl ptr pea OS9svc\@(pc) set return address move.l \1+\1+\1+\1(a3),-(a7) set OS9 service routine ptr movea.l \1+\1+\1+\1+256*4(a3),a3 get service routine data ptr rts execute service routineOS9svc\@ movea.l (a7)+,a3 restore reg endm********************************* ldbra macro - extend dbra loop to long register count* arguments: \1=Dn, register to decrement*            \2=(short) destination addressldbra macro dbra \1,\2 addq.w #1,\1 subq.l #1,\1 bcc.s \2 endm********************************* Macro roundup (\1=blocksize, \2=number, [\3=fast])*   Rounds destination register up to nearest source blocksize.* Source and destination fields must be D-registers.  Source* register must be an exact power of two.* If the third (optional) argument is present, and is the string* "fast", slightly faster code is generated, at the expense of* destroying the source register.  In this case, the condition* code register will be set correctly to reflect the result of* the rounding operation.roundup macro iflt \#-2 fail roundup: requires two arguments endc ifne \L1-2 fail roundup: first argument must be a d register endc ifne \L2-2 fail roundup: second argument must be a d register endc add.l \1,\2 round request up to nearest block size subq.l #1,\2 neg.l \1 form truncation mask and.l \1,\2 truncate result to even block iflt \#-3	neg.l \1 restore register else	ifne '\3'-'fast'	neg.l \1 restore register	endc endc endm********************************* macro ChkOvf <D-reg>*	Check for arithmetic overflow; return MAXINT or MININT.ChkOvf macro bvc.s Ovf\@ continue if no overflow moveq.l #-1,\1 reset to ffffffff roxr.l #1,\1 get MAXINT if overflow bpl.s Ovf\@ exit if overflow lsr.l #1,\1 set to 7fffffff not.l \1 complement to form MININTOvf\@ endm********************************* sysglob (An) macro*  	Get system global storage ptr.  (Only needed by excpt.a).sysglob macro ifne \#-1   fail sysglob: requires one (A-reg) argument endc ifne \L1-2   fail sysglob: argument must be an A register" endc ifndef ATARI ifdef MPU020.030   movec vbr,\1   movea.l (\1),\1 else (68000)   movea.l 0.w,\1 endc MPU020.030 else (Atari ST) movea.l $4fa.w,\1 endc ATARI endm ifdef MPU020.030 use fpumacs.d endc opt l